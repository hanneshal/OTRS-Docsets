<html><head><title>Kernel::GenericInterface::Invoker</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.28,
  using Pod::Simple::PullParser v3.28,
  under Perl v5.018004 at Tue Feb 16 20:51:16 2021 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#PUBLIC_INTERFACE'>PUBLIC INTERFACE</a>
  <li class='indexItem indexItem1'><a href='#TERMS_AND_CONDITIONS'>TERMS AND CONDITIONS</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
><a name='//apple_ref/cpp/Class/NAME' class='dashAnchor'></a>NAME</a></h1>

<p>Kernel::GenericInterface::Invoker - GenericInterface Invoker interface</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
><a name='//apple_ref/cpp/Class/SYNOPSIS' class='dashAnchor'></a>SYNOPSIS</a></h1>

<p>Invokers are responsible to prepare for making a remote web service request.</p>

<p>For every Request,
two methods are called:</p>

<dl>
<dt><a name="&#34;PrepareRequest()&#34;"
><a href="#PrepareRequest()" class="podlinkpod"
>&#34;PrepareRequest()&#34;</a></a></dt>

<dd>
<dt><a name="&#34;HandleResponse()&#34;"
><a href="#HandleResponse()" class="podlinkpod"
>&#34;HandleResponse()&#34;</a></a></dt>
</dl>

<p>The first method prepares the response and can prevent it by returning an error state.
The second method must always be called if the request was initiated to allow the Invoker to handle possible errors.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="PUBLIC_INTERFACE"
><a name='//apple_ref/cpp/Class/PUBLIC INTERFACE' class='dashAnchor'></a>PUBLIC INTERFACE</a></h1>

<dl>
<dt><a name="new()"
>new()</a></dt>

<dd>
<p>create an object.</p>

<pre>    use Kernel::GenericInterface::Debugger;
    use Kernel::GenericInterface::Invoker;

    my $DebuggerObject = Kernel::GenericInterface::Debugger-&#62;new(
        DebuggerConfig   =&#62; {
            DebugThreshold =&#62; &#39;debug&#39;,
            TestMode       =&#62; 0,           # optional, in testing mode the data will not be written to the DB
            # ...
        },
        WebserviceID      =&#62; 12,
        CommunicationType =&#62; Requester, # Requester or Provider
        RemoteIP          =&#62; 192.168.1.1, # optional
    );
    my $InvokerObject = Kernel::GenericInterface::Invoker-&#62;new(
        DebuggerObject     =&#62; $DebuggerObject,
        Invoker            =&#62; &#39;TicketLock&#39;,            # the name of the invoker in the web service
        InvokerType        =&#62; &#39;Nagios::TicketLock&#39;,    # the Invoker backend to use
        WebserviceID       =&#62; 1                        # the WebserviceID where the Invoker belongs
                                                       # normally this is passed by the requester
    );</pre>

<dt><a name="PrepareRequest()"
>PrepareRequest()</a></dt>

<dd>
<p>prepare the invocation of the configured remote webservice.</p>

<pre>    my $Result = $InvokerObject-&#62;PrepareRequest(
        Data =&#62; {                               # data payload
            ...
        },
    );

    $Result = {
        Success         =&#62; 1,                   # 0 or 1
        ErrorMessage    =&#62; &#39;&#39;,                  # in case of error
        Data            =&#62; {                    # data payload after Invoker
            ...
        },
    };

    $Result = {
        Success           =&#62; 1,                 # 0 or 1
        StopCommunication =&#62; 1,                 # in case of is not needed to continue with the
                                                # request (do nothing just exist gracefully)
    };</pre>

<dt><a name="HandleResponse()"
>HandleResponse()</a></dt>

<dd>
<p>handle response data of the configured remote webservice.</p>

<pre>    my $Result = $InvokerObject-&#62;HandleResponse(
        ResponseSuccess      =&#62; 1,              # success status of the remote webservice
        ResponseErrorMessage =&#62; &#39;&#39;,             # in case of webservice error
        Data =&#62; {                               # data payload
            ...
        },
    );

    $Result = {
        Success         =&#62; 1,                   # 0 or 1
        ErrorMessage    =&#62; &#39;&#39;,                  # in case of error
        Data            =&#62; {                    # data payload after Invoker
            ...
        },
    };</pre>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="TERMS_AND_CONDITIONS"
><a name='//apple_ref/cpp/Class/TERMS AND CONDITIONS' class='dashAnchor'></a>TERMS AND CONDITIONS</a></h1>

<p>This software is part of the OTRS project (<a href="https://otrs.org/" class="podlinkurl"
>https://otrs.org/</a>).</p>

<p>This software comes with ABSOLUTELY NO WARRANTY. For details, see the enclosed file COPYING for license information (GPL). If you did not receive this file, see <a href="https://www.gnu.org/licenses/gpl-3.0.txt" class="podlinkurl"
>https://www.gnu.org/licenses/gpl-3.0.txt</a>.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
