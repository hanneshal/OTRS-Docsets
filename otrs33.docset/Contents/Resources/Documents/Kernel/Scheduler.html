<html><head><title>Kernel::Scheduler</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >

<script type="text/javascript" src="../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.28,
  using Pod::Simple::PullParser v3.28,
  under Perl v5.018002 at Sun Mar 20 20:33:42 2016 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Registering_new_scheduler_tasks'>Registering new scheduler tasks</a>
    <li class='indexItem indexItem2'><a href='#Running_pending_tasks'>Running pending tasks</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#PUBLIC_INTERFACE'>PUBLIC INTERFACE</a>
  <li class='indexItem indexItem1'><a href='#TERMS_AND_CONDITIONS'>TERMS AND CONDITIONS</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Kernel::Scheduler - Scheduler lib</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<p>This object can be used in two ways:</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Registering_new_scheduler_tasks"
>Registering new scheduler tasks</a></h2>

<p>By creating an instance of this object and calling <a href="../TaskRegister().html" class="podlinkpod"
>TaskRegister()</a> on it,
a task can be scheduled for asynchronous execution (either as soon as possible,
or with a specified future execution time).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Running_pending_tasks"
>Running pending tasks</a></h2>

<p>From the scheduler daemon,
the <a href="../Run().html" class="podlinkpod"
>Run()</a> method will be called to find and process all existing tasks.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="PUBLIC_INTERFACE"
>PUBLIC INTERFACE</a></h1>

<dl>
<dt><a name="new()"
>new()</a></dt>

<dd>
<p>create an object.</p>

<pre>    use Kernel::Config;
    use Kernel::System::Encode;
    use Kernel::System::Log;
    use Kernel::System::Time;
    use Kernel::System::Main;
    use Kernel::System::DB;
    use Kernel::Scheduler;

    my $ConfigObject = Kernel::Config-&#62;new();
    my $EncodeObject = Kernel::System::Encode-&#62;new(
        ConfigObject =&#62; $ConfigObject,
    );
    my $LogObject = Kernel::System::Log-&#62;new(
        ConfigObject =&#62; $ConfigObject,
        EncodeObject =&#62; $EncodeObject,
    );
    my $TimeObject = Kernel::System::Time-&#62;new(
        ConfigObject =&#62; $ConfigObject,
        LogObject    =&#62; $LogObject,
    );
    my $MainObject = Kernel::System::Main-&#62;new(
        ConfigObject =&#62; $ConfigObject,
        EncodeObject =&#62; $EncodeObject,
        LogObject    =&#62; $LogObject,
    );
    my $DBObject = Kernel::System::DB-&#62;new(
        ConfigObject =&#62; $ConfigObject,
        EncodeObject =&#62; $EncodeObject,
        LogObject    =&#62; $LogObject,
        MainObject   =&#62; $MainObject,
    );
    my $SchedulerObject = Kernel::Scheduler-&#62;new(
        ConfigObject =&#62; $ConfigObject,
        LogObject    =&#62; $LogObject,
        TimeObject   =&#62; $TimeObject,
        DBObject     =&#62; $DBObject,
        MainObject   =&#62; $MainObject,
        EncodeObject =&#62; $EncodeObject,
    );</pre>

<dt><a name="Run()"
>Run()</a></dt>

<dd>
<p>find and dispatch pending tasks. This method is used from the scheduler daemon to regularly find and execute all pending tasks.</p>

<pre>    my $Success = $SchedulerObject-&#62;Run();

    $Success = 1                   # 0 or 1;</pre>

<dt><a name="TaskRegister()"
>TaskRegister()</a></dt>

<dd>
<p>schedules a task for asynchronous execution (either as soon as possible, or with a specified future execution time). Each task has a task type, and for each task type a corresponding task handler backend must be present. The task data that is required depends on the task type. Please consult the task handler backend specification to find out which data is exactly needed.</p>

<pre>    my $TaskID = $SchedulerObject-&#62;TaskRegister(
        Type     =&#62; &#39;GenericInterface&#39;,
        Data     =&#62; {                               # task data, depends task handler backend
            ...
        },
        DueTime  =&#62; &#39;2006-01-19 23:59:59&#39;,          # optional (default current time)
    );</pre>

<dt><a name="_SanityChecks()"
>_SanityChecks()</a></dt>

<dd>
<p>performs checks for the currently registered tasks.</p>

<dt><a name="_PIDChangedTimeUpdate()"
>_PIDChangedTimeUpdate()</a></dt>

<dd>
<p>Check if is the case to update the changed time for the PID, in order to use it as a keep alive signal.</p>

<pre>    my $Success = $SchedulerObject-&#62;_PIDChangedTimeUpdate();</pre>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="TERMS_AND_CONDITIONS"
>TERMS AND CONDITIONS</a></h1>

<p>This software is part of the OTRS project (<a href="http://otrs.org/" class="podlinkurl"
>http://otrs.org/</a>).</p>

<p>This software comes with ABSOLUTELY NO WARRANTY. For details, see the enclosed file COPYING for license information (AGPL). If you did not receive this file, see <a href="http://www.gnu.org/licenses/agpl.txt" class="podlinkurl"
>http://www.gnu.org/licenses/agpl.txt</a>.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
